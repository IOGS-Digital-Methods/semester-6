
---

## üß† 1. Structures de base du C++ pour l‚Äôembarqu√©

### ‚öôÔ∏è a) Variables et types

* Types simples : `int`, `float`, `bool`, `char`, `uint8_t`, `uint16_t`, `uint32_t`, etc.
* Types sp√©cifiques au mat√©riel : d√©finis dans `<cstdint>` pour une **taille contr√¥l√©e**.
  ‚Üí Indispensable en embarqu√© (ex. : `uint8_t ledState = 0;`).

### ‚öôÔ∏è b) Structures (`struct`)

* Utilis√©es pour **regrouper des donn√©es** li√©es, souvent pour des p√©riph√©riques ou des capteurs.

  ```cpp
  struct SensorData {
      float temperature;
      float humidity;
  };
  SensorData data;
  ```
* Souvent manipul√©es avec des **r√©f√©rences** ou des **pointeurs** pour limiter les copies.

---

## üß© 2. Classes et objets

Mbed OS est orient√© objet : la plupart des √©l√©ments du framework sont des **classes** C++.

### Exemple :

```cpp
DigitalOut led(LED1);
DigitalIn button(BUTTON1);
```

* `DigitalOut` et `DigitalIn` sont des classes d√©finies dans Mbed OS.
* Chaque instance est **li√©e √† un pin physique** du microcontr√¥leur.

### Points cl√©s :

* **Encapsulation** : permet de cacher les d√©tails bas niveau.
* **Constructeurs** : configurent les p√©riph√©riques.
* **M√©thodes** : manipulent le mat√©riel (ex. `led = 1;` ou `led.write(0);`).
* **Destructeurs** : rarement utilis√©s, mais importants pour lib√©rer les ressources dans certains contextes RTOS.

---

## üîÅ 3. Pointeurs, r√©f√©rences et m√©moire

### Pourquoi importants :

* Permettent de manipuler directement le mat√©riel (registres, buffers DMA, etc.).
* N√©cessaires pour passer des objets lourds sans copie.

```cpp
void readSensor(SensorData* data);
```

### Bonnes pratiques :

* √âviter l‚Äôallocation dynamique (`new`, `malloc`) ‚Äî privil√©gier la **pile (stack)**.
* En RTOS, utiliser des **buffers statiques** ou des **pools m√©moire**.

---

## üïπÔ∏è 4. Classes Mbed OS essentielles

| Classe                       | R√¥le                             | Exemple                                         |
| ---------------------------- | -------------------------------- | ----------------------------------------------- |
| `DigitalOut`                 | G√©rer une sortie num√©rique       | `DigitalOut led(LED1); led = 1;`                |
| `DigitalIn`                  | Lire une entr√©e num√©rique        | `DigitalIn button(BUTTON1); if (button) ‚Ä¶`      |
| `AnalogIn`                   | Lire une entr√©e analogique (ADC) | `AnalogIn sensor(A0); float v = sensor.read();` |
| `PwmOut`                     | G√©n√©rer un signal PWM            | `PwmOut motor(D3); motor.write(0.5f);`          |
| `Serial` ou `BufferedSerial` | Communication UART               | `BufferedSerial pc(USBTX, USBRX);`              |
| `Ticker`                     | Timer p√©riodique (ISR)           | `Ticker tick; tick.attach(callback, 1.0);`      |
| `Thread`                     | T√¢che concurrente (RTOS)         | `Thread t; t.start(task_function);`             |
| `Mutex`, `Semaphore`         | Synchronisation                  | `mutex.lock(); ... mutex.unlock();`             |

---

## üßµ 5. RTOS et multit√¢che (Mbed OS 6+)

Mbed OS int√®gre **mbed::rtos**, bas√© sur **CMSIS-RTOS** (souvent FreeRTOS en backend).

### Exemples :

```cpp
Thread thread1;
void blink() {
    while (true) {
        led = !led;
        ThisThread::sleep_for(500ms);
    }
}
int main() {
    thread1.start(blink);
}
```

### Structures associ√©es :

* `Thread` ‚Üí t√¢che ind√©pendante
* `Mutex`, `Semaphore` ‚Üí synchronisation
* `EventQueue` ‚Üí gestion d‚Äô√©v√©nements (plus efficace que `while(true)` avec `sleep_for`)

---

## ‚è±Ô∏è 6. Structures temporelles

* `ThisThread::sleep_for(chrono::milliseconds(500));`
* `Timer` ‚Üí mesure d‚Äôintervalles
* `Ticker` ‚Üí interruptions p√©riodiques
* `Timeout` ‚Üí ex√©cution diff√©r√©e

---

## ‚ö° 7. Callbacks et lambdas

Mbed OS utilise largement les **callbacks** (fonction √† rappeler plus tard, souvent dans une interruption ou un event queue).

```cpp
Ticker tick;
void toggle_led() { led = !led; }

int main() {
    tick.attach(callback(toggle_led), 500ms);
}
```

Peut aussi √™tre fait avec une **lambda** :

```cpp
tick.attach([] { led = !led; }, 500ms);
```

---

## üß∞ 8. Bonnes pratiques C++ pour l‚Äôembarqu√©

* Utiliser des **const**, **constexpr**, **enum class**.
* √âviter les exceptions et la STL compl√®te (trop lourde).
* Pr√©f√©rer `#define` ou `constexpr` pour les constantes.
* Toujours surveiller l‚Äôusage m√©moire et le temps d‚Äôex√©cution.

---

## üìò En r√©sum√©

| Cat√©gorie         | Structure cl√©                                   | Utilisation typique        |
| ----------------- | ----------------------------------------------- | -------------------------- |
| Entr√©es/Sorties   | `DigitalIn`, `DigitalOut`, `AnalogIn`, `PwmOut` | Contr√¥le du mat√©riel       |
| Temps             | `Timer`, `Ticker`, `Timeout`                    | Mesures et interruptions   |
| Concurrence       | `Thread`, `Mutex`, `Semaphore`, `EventQueue`    | RTOS                       |
| Programmation C++ | `class`, `struct`, `callback`, `lambda`         | Architecture et modularit√© |
| Types et m√©moire  | `uint32_t`, `constexpr`, pointeurs              | Efficacit√© et s√©curit√©     |

---

Souhaites-tu que je te fasse une **fiche condens√©e au format A4** (pour r√©vision ou impression) avec les √©l√©ments essentiels et exemples minimalistes ?
