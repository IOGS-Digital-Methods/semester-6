---

# üß™ **TP3 ‚Äì √âclairage et propri√©t√©s des objets**

## üéØ Objectifs p√©dagogiques

√Ä la fin du TP, l‚Äô√©tudiant est capable de :

* Identifier les diff√©rents types d‚Äô√©clairage utilis√©s en vision industrielle (direct, diffus, rasant, coaxial‚Ä¶).
* Comprendre l‚Äôimpact du **spectre lumineux** et de la **couleur de l‚Äô√©clairage** sur le contraste.
* Relier la **r√©flectance** d‚Äôun mat√©riau (objet) √† la qualit√© de l‚Äôimage.
* Choisir un √©clairage optimal pour mettre en √©vidence un d√©faut ou une caract√©ristique.

---

## üîß Mat√©riel

* **Cam√©ra CMOS couleur**.
* **Ring RGB** (√©clairage rouge, vert, bleu) ou plusieurs LEDs de couleurs distinctes.
* √âclairage diffus / direct / rasant si possible (ou r√©alisation artisanale : papier calque, miroir, lampe inclin√©e).
* Objets vari√©s : plastique brillant, m√©tal poli, pi√®ce mate, √©tiquette color√©e, pi√®ce avec gravure.
* PC avec `pypylon`, `opencv`, `numpy`, `matplotlib`.

---

## üïì **D√©roul√© (4h)**

| Temps       | √âtape                                   | Description                                                                                               |
| ----------- | --------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| 0h00 ‚Äì 0h20 | **Introduction**                        | Th√©orie sur la lumi√®re : spectre, temp√©rature de couleur, r√©flexion sp√©culaire vs diffuse.                |
| 0h20 ‚Äì 1h00 | **Types d‚Äô√©clairage**                   | Exp√©riences avec √©clairage direct, rasant, diffus. Observation des effets sur le contraste et les ombres. |
| 1h00 ‚Äì 2h00 | **Influence de la couleur d‚Äô√©clairage** | Acquisition d‚Äôimages sous LED R/G/B, analyse de contraste et de canaux de couleur.                        |
| 2h00 ‚Äì 3h00 | **R√©flectance et texture des objets**   | Observation de pi√®ces mates/brillantes. Comparaison des intensit√©s et histogrammes.                       |
| 3h00 ‚Äì 4h00 | **Mini-projet**                         | Choix du meilleur √©clairage pour d√©tecter un d√©faut ou un marquage. Discussion sur les compromis.         |

---

## üìÑ **Sujet √©tudiant**

### Partie 1 ‚Äî Effet de la g√©om√©trie d‚Äô√©clairage

1. Placez une pi√®ce m√©canique brillante (ou une bille) sur un fond sombre.
2. Capturez l‚Äôimage avec :

   * √©clairage **direct frontal**,
   * √©clairage **rasant** (lampe inclin√©e),
   * √©clairage **diffus** (papier calque devant la lampe).
3. Comparez les ombres, reflets, et contraste global.

‚û°Ô∏è **Question :** quel type d‚Äô√©clairage met le mieux en √©vidence la forme ? la texture ?

---

### Partie 2 ‚Äî Influence de la couleur d‚Äô√©clairage

1. Allumez successivement les canaux R, G, B du ring.
2. Capturez 3 images : `img_R`, `img_G`, `img_B`.
3. Analysez les histogrammes de chaque image (intensit√© moyenne).
4. Observez quel √©clairage maximise le contraste entre deux zones color√©es (par ex. rouge vs vert).

üßÆ *Id√©e :* mesurer la **diff√©rence de contraste** entre fond et marquage :
[
C = \frac{|I_{objet} - I_{fond}|}{I_{objet} + I_{fond}}
]

---

### Partie 3 ‚Äî R√©flectance et texture

1. Choisissez deux objets : un **mat** et un **brillant**.
2. Sous le m√™me √©clairage, capturez et mesurez :

   * l‚Äôintensit√© moyenne d‚Äôune zone (r√©flectance relative),
   * la variance locale (texture).
3. Comparez : pourquoi le m√©tal sature-t-il plus vite ?
4. Si possible, utilisez un **filtre polarisant** pour montrer la r√©duction des reflets.

---

### Partie 4 ‚Äî Mini-projet industriel

1. Choisissez un objet comportant un **d√©faut difficile √† voir** (rayure, √©tiquette partielle, marquage faible).
2. Testez au moins **3 configurations d‚Äô√©clairage** (g√©om√©trie et couleur).
3. Identifiez celle qui **maximise la d√©tection** du d√©faut.
4. Documentez avec images, histogrammes et mesure de contraste.

---

## üíª **√âl√©ments de code / correction**

### 1Ô∏è‚É£ S√©paration des canaux R, G, B

```python
import cv2, numpy as np
import matplotlib.pyplot as plt

img = cv2.imread("piece_rgb.png")
b,g,r = cv2.split(img)

plt.figure(figsize=(10,4))
plt.subplot(1,3,1); plt.imshow(r, cmap='gray'); plt.title('Canal Rouge')
plt.subplot(1,3,2); plt.imshow(g, cmap='gray'); plt.title('Canal Vert')
plt.subplot(1,3,3); plt.imshow(b, cmap='gray'); plt.title('Canal Bleu')
plt.show()
```

---

### 2Ô∏è‚É£ Histogrammes et intensit√©s moyennes

```python
def mean_intensity(channel):
    return np.mean(channel)

print("Intensit√© moyenne R:", mean_intensity(r))
print("Intensit√© moyenne G:", mean_intensity(g))
print("Intensit√© moyenne B:", mean_intensity(b))

# Histogramme
plt.hist(r.ravel(), 256, [0,256], color='r', alpha=0.5)
plt.hist(g.ravel(), 256, [0,256], color='g', alpha=0.5)
plt.hist(b.ravel(), 256, [0,256], color='b', alpha=0.5)
plt.title("Histogrammes des canaux RGB")
plt.show()
```

---

### 3Ô∏è‚É£ Calcul de contraste entre deux zones

```python
# D√©finir deux zones manuellement (fond et objet)
zone1 = img[100:150, 100:150]  # objet
zone2 = img[200:250, 200:250]  # fond

I1, I2 = np.mean(zone1), np.mean(zone2)
C = abs(I1 - I2) / (I1 + I2)
print(f"Contraste entre objet et fond : {C:.3f}")
```

---

### 4Ô∏è‚É£ Mesure de texture (variance locale)

```python
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
local_var = cv2.Laplacian(gray, cv2.CV_64F).var()
print(f"Variance locale (texture) : {local_var:.2f}")
```

---

### 5Ô∏è‚É£ Exemple de d√©tection de d√©faut par contraste adaptatif

```python
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
blur = cv2.GaussianBlur(gray, (11,11), 0)
th = cv2.adaptiveThreshold(blur, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                           cv2.THRESH_BINARY_INV, 25, 10)
cv2.imshow("D√©fauts d√©tect√©s", th)
cv2.waitKey(0)
```

---

## üß† **Questions de r√©flexion**

1. Pourquoi un √©clairage rouge am√©liore-t-il parfois le contraste d‚Äôun objet vert ?
2. Quelle combinaison d‚Äô√©clairage g√©om√©trie + spectre est optimale pour un objet brillant ?
3. Quelles limitations physiques apparaissent avec un √©clairage rasant ?

---

## üí° **Extension possible**

* Ajouter une exp√©rience de **correction d‚Äôillumination non uniforme** :

  ```python
  # Correction d‚Äô√©clairage (flat-field)
  flat = cv2.imread("eclairage_uniforme.png", cv2.IMREAD_GRAYSCALE).astype(np.float32)
  image = cv2.imread("piece.png", cv2.IMREAD_GRAYSCALE).astype(np.float32)
  corrected = cv2.normalize(image / flat, None, 0, 255, cv2.NORM_MINMAX)
  cv2.imshow("Image corrig√©e", corrected.astype(np.uint8))
  cv2.waitKey(0)
  ```
* Permet d‚Äôintroduire les notions d‚Äô**√©talonnage photom√©trique** et de correction de fond.

---