
---

# ğŸ§ª **TP4 â€“ Post-traitement et application intÃ©grÃ©e**

## ğŸ¯ Objectifs pÃ©dagogiques

Ã€ la fin du TP, lâ€™Ã©tudiant est capable de :

* Mettre en Å“uvre une **chaÃ®ne complÃ¨te de vision industrielle** (acquisition â†’ traitement â†’ dÃ©cision).
* Appliquer des techniques de **segmentation, dÃ©tection de contours, et mesure**.
* Calibrer les dimensions de lâ€™image en unitÃ©s physiques (mm/pixel).
* Concevoir une mini-application dâ€™inspection simple avec interface utilisateur.

---

## ğŸ”§ MatÃ©riel

* CamÃ©ra CMOS (couleur ou mono) + objectif + Ã©clairage optimisÃ© (issu des TP prÃ©cÃ©dents).
* Objets Ã  inspecter : piÃ¨ces mÃ©caniques, bouchons colorÃ©s, composants, capsules, connecteurs, etc.
* PC avec `pypylon`, `opencv`, `numpy`, `matplotlib`, `tkinter` (ou PyQt si souhaitÃ©).

---

## ğŸ•“ **DÃ©roulÃ© (4h)**

| Temps       | Ã‰tape                                 | Description                                                                           |
| ----------- | ------------------------------------- | ------------------------------------------------------------------------------------- |
| 0h00 â€“ 0h30 | **Rappel de la chaÃ®ne complÃ¨te**      | CamÃ©ra â†’ Optique â†’ Ã‰clairage â†’ Traitement. Choix dâ€™une application fil rouge.         |
| 0h30 â€“ 1h30 | **Calibration et acquisition**        | Capture dâ€™une mire, calcul du facteur mm/pixel, configuration des paramÃ¨tres dâ€™image. |
| 1h30 â€“ 2h30 | **Traitement dâ€™image**                | Seuillage, dÃ©tection de contours, morphologie, mesure de dimensions ou couleurs.      |
| 2h30 â€“ 3h30 | **DÃ©cision / inspection automatique** | DÃ©tection dâ€™anomalie ou mesure par rapport Ã  une tolÃ©rance.                           |
| 3h30 â€“ 4h00 | **SynthÃ¨se et IHM simple**            | Interface de visualisation, choix des seuils, affichage du verdict (OK/NOK).          |

---

## ğŸ“„ **Sujet Ã©tudiant**

### Partie 1 â€” Calibration gÃ©omÃ©trique

1. Placez une rÃ©glette ou mire avec graduation connue (ex : 10 mm).
2. Capturez une image nette.
3. Mesurez la distance (en pixels) correspondant Ã  10 mm.
4. Calculez lâ€™Ã©chelle (mm/pixel).
5. Sauvegardez ce facteur pour les mesures ultÃ©rieures.

---

### Partie 2 â€” Acquisition et prÃ©paration

1. Capturez plusieurs images dâ€™un mÃªme type de piÃ¨ce (au moins 5).
2. Choisissez les meilleurs rÃ©glages (exposition, Ã©clairage, diaphragme).
3. Convertissez lâ€™image en niveaux de gris et appliquez une **correction dâ€™Ã©clairage** si nÃ©cessaire.
4. Lissez lâ€™image (filtre gaussien ou mÃ©dian).

---

### Partie 3 â€” Segmentation et dÃ©tection de contours

1. Appliquez un **seuillage automatique** (`cv2.THRESH_OTSU`) ou adaptatif.
2. DÃ©tectez les **contours** avec `cv2.findContours()`.
3. Identifiez le contour principal (piÃ¨ce) et dessinez-le sur lâ€™image.
4. Calculez la **surface** et les **dimensions principales** (en mm).

---

### Partie 4 â€” Mesure et contrÃ´le

1. Comparez les mesures Ã  une **tolÃ©rance** donnÃ©e (ex. diamÃ¨tre 20 Â± 0,5 mm).
2. Affichez un **verdict OK / NOK** en surimpression sur lâ€™image.
3. (Option) Si la camÃ©ra est couleur, ajoutez une **vÃ©rification de teinte dominante** (tri par couleur).

---

### Partie 5 â€” Interface utilisateur (IHM)

1. CrÃ©ez une fenÃªtre simple permettant de :

   * lancer une capture,
   * afficher lâ€™image et le contour dÃ©tectÃ©,
   * montrer les mesures et le verdict.
2. Bonus : ajout dâ€™un **curseur de seuil** ou dâ€™un **bouton â€œSauvegarderâ€**.

---

## ğŸ’» **Ã‰lÃ©ments de code / correction**

### 1ï¸âƒ£ Calibration gÃ©omÃ©trique

```python
import cv2, numpy as np

img = cv2.imread("mire.png", cv2.IMREAD_GRAYSCALE)
cv2.imshow("Mire", img)
cv2.waitKey(0)

# Mesure manuelle sur 10 mm (Ã  lâ€™aide de selectROIs)
r = cv2.selectROIs("Image", img)
cv2.destroyAllWindows()

pix_dist = abs(r[0][0] - r[1][0])  # nombre de pixels entre les marques
mm_per_pix = 10 / pix_dist
print(f"Ã‰chelle : {mm_per_pix:.4f} mm/pixel")
```

---

### 2ï¸âƒ£ Segmentation et dÃ©tection de contours

```python
img = cv2.imread("piece.png")
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
blur = cv2.GaussianBlur(gray, (5,5), 0)
_, th = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

contours, _ = cv2.findContours(th, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(img, contours, -1, (0,255,0), 2)
cv2.imshow("Contours dÃ©tectÃ©s", img)
cv2.waitKey(0)
```

---

### 3ï¸âƒ£ Mesures de dimensions

```python
# Supposons un seul contour principal
cnt = max(contours, key=cv2.contourArea)
(x, y), (w, h), angle = cv2.minAreaRect(cnt)
diam = (w + h) / 2 * mm_per_pix

print(f"DiamÃ¨tre moyen : {diam:.2f} mm")

# Surface
area = cv2.contourArea(cnt) * (mm_per_pix**2)
print(f"Surface : {area:.2f} mmÂ²")
```

---

### 4ï¸âƒ£ DÃ©cision et affichage du verdict

```python
tol_inf, tol_sup = 19.5, 20.5
verdict = "OK" if tol_inf <= diam <= tol_sup else "NOK"
color = (0,255,0) if verdict == "OK" else (0,0,255)

cv2.putText(img, f"{verdict} ({diam:.2f} mm)", (50,50),
            cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)
cv2.imshow("Inspection", img)
cv2.waitKey(0)
```

---

### 5ï¸âƒ£ Mini-IHM simple (capture et traitement)

```python
import tkinter as tk
from tkinter import Button
import cv2
from pypylon import pylon

camera = pylon.InstantCamera(pylon.TlFactory.GetInstance().CreateFirstDevice())
camera.Open()

def capture_and_process():
    camera.StartGrabbingMax(1)
    grab = camera.RetrieveResult(5000, pylon.TimeoutHandling_ThrowException)
    if grab.GrabSucceeded():
        img = grab.Array
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        _, th = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        contours, _ = cv2.findContours(th, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        cv2.drawContours(img, contours, -1, (0,255,0), 2)
        cv2.imshow("RÃ©sultat", img)
        cv2.waitKey(1)
    grab.Release()

root = tk.Tk()
root.title("Inspection Vision")
btn = Button(root, text="Capturer", command=capture_and_process)
btn.pack(padx=20, pady=20)
root.mainloop()
camera.Close()
```

---

## ğŸ§  **Questions de rÃ©flexion**

1. Quelle est la principale source dâ€™erreur dans une mesure dimensionnelle par vision ?
2. Comment amÃ©liorer la stabilitÃ© dâ€™un systÃ¨me de vision industrielle ?
3. Pourquoi est-il important dâ€™Ã©talonner la camÃ©ra avant toute mesure prÃ©cise ?
4. Quelles amÃ©liorations pourrait-on ajouter pour un systÃ¨me de tri automatique ?

---

## ğŸ’¡ **Extensions possibles**

* Lecture de code QR ou marquage (`cv2.QRCodeDetector`).
* Sauvegarde automatique des rÃ©sultats dans un fichier CSV.
* DÃ©tection multicritÃ¨re (forme + couleur).
* Utilisation dâ€™un **trigger matÃ©riel** pour la capture synchrone.

---
